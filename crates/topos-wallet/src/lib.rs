use std::fs;
use std::path::PathBuf;

pub mod error;

// File tree generated by Polygon Edge

/// Key for the authentication on libp2p (secp256k1)
pub const NETWORK_KEY: &str = "libp2p/libp2p.key";
/// Key for the contracts authentication (secp256k1)
pub const VALIDATOR_KEY: &str = "consensus/validator.key";
/// Key for the IBFT authentication (bls)
pub const VALIDATOR_BLS_KEY: &str = "consensus/validator-bls.key";

/// Load from the filesystem
pub fn load_fs_secret(file: PathBuf) -> Option<SecretKey> {
    match &fs::read_to_string(&file) {
        Ok(s) => Some(hex::decode(s).unwrap_or_else(|_| panic!("decode failure for {}", s))),
        Err(e) => panic!("Failed at reading {file:?}: {e}"),
    }
}

/// Load from the AWS Secret Manager
#[allow(dead_code)]
pub fn load_aws_secrets(secrets_config: &str) {
    println!("loading from aws-sm {}", secrets_config);
}

pub type SecretKey = Vec<u8>;
pub type PublicKey = Vec<u8>;

#[derive(Default, Debug)]
pub struct SecretManager {
    pub network: Option<SecretKey>,
    pub validator: Option<SecretKey>,
    pub validator_bls: Option<SecretKey>,
}

impl SecretManager {
    pub fn from_fs(home_path: PathBuf) -> Self {
        Self {
            network: load_fs_secret(home_path.join(NETWORK_KEY)),
            validator: load_fs_secret(home_path.join(VALIDATOR_KEY)),
            validator_bls: load_fs_secret(home_path.join(VALIDATOR_BLS_KEY)),
        }
    }

    pub fn from_aws(_secrets_config: &str) -> Self {
        println!("loading from aws-sm");
        todo!()
    }

    pub fn validator_pubkey(&self) -> Option<PublicKey> {
        self.validator
            .as_ref()
            .map(|pk| topos_crypto::keys::derive_public_key(pk).unwrap())
    }
}
